# -*- coding: utf-8 -*-
"""Function_Plotting_and_Visualization

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NCdYJN4_Ly76HKyYEWl5VZ9549Gl0Pph
"""

# Plotting Functions using Matplotlib

import matplotlib.pyplot as plt
import numpy as np

# Define range for x values
xmin = -2 * np.pi  # Fixed values
xmax = 2 * np.pi

# Create an array of x values
x = np.arange(xmin, xmax, 0.1)

# Define functions for y values
y1 = -np.sin(x) * np.cos(x)  # f(x) = -sin(x)*cos(x)

# Avoid division by zero error for x=0
y2 = np.sin(x) / x
y2[x == 0] = 0  # Set the value at x=0 explicitly

# Plot functions together
plt.figure(figsize=(10, 5))
plt.xlabel('x')
plt.ylabel('y(x)')
plt.title("Plotting Two Functions Together")
plt.plot(x, y1, '1', lw=2, label="Sin(x)Cos(x)")
plt.plot(x, y2, '.', lw=2, label="Sinc(x)")
plt.legend()
plt.grid()

# Save the plot to a PDF file
plt.savefig("twofunc.pdf")

# Show the plot
plt.show()

"""# Plotting Subplots"""

xmin, xmax, Npoints = -5, 5, 500
dx = (xmax - xmin) / Npoints

# Create x arrays for different resolutions
x1 = np.arange(xmin, xmax, dx)
x2 = np.arange(xmin, xmax, dx / 20)

# Define functions for y values
y1 = -np.sin(x1) * np.cos(x1 * x1)
y2 = np.exp(-x2 / 4) * np.sin(x2)
y3 = np.exp(-x1 ** 2 / 4)
y4 = np.sin(x2)

# Create subplots
plt.figure(figsize=(10, 5))

plt.subplot(2, 2, 1)   # 2 rows, 2 columns, plot1
plt.plot(x1, y1, 'r', lw=2)

plt.subplot(2, 2, 2)   # 2 rows, 2 columns, plot2
plt.plot(x2, y2, '-', lw=2)

plt.subplot(2, 2, 3)   # 2 rows, 2 columns, plot3
plt.plot(x1, y3, 'k--', lw=2)

plt.subplot(2, 2, 4)   # 2 rows, 2 columns, plot4
plt.plot(x2, y4, '+g', lw=1)

# Tight layout and show all subplots at once
plt.tight_layout()
plt.show()

# Save subplots as PDF (after plt.show())
plt.savefig("subplotexample.pdf")

import matplotlib.pyplot as plt
import numpy as np

# --- Plotting Two Functions Together ---
def plot_two_functions():
    # Define range for x values
    xmin = -2 * np.pi  # Minimum x value
    xmax = 2 * np.pi   # Maximum x value

    # Create an array of x values from xmin to xmax with a step of 0.1
    x = np.arange(xmin, xmax, 0.1)

    # Define the functions for y values
    y1 = -np.sin(x) * np.cos(x)  # f(x) = -sin(x) * cos(x)

    # Avoid division by zero error for x=0
    y2 = np.sin(x) / x
    y2[x == 0] = 0  # Set the value at x=0 explicitly (to avoid NaN values)

    # Create a figure and axis objects
    plt.figure(figsize=(10, 5))

    # Plot the first function (Sin(x)*Cos(x)) with red line
    plt.plot(x, y1, 'r-', lw=2, label="f(x) = -sin(x) * cos(x)")

    # Plot the second function (Sinc(x)) with blue dotted line
    plt.plot(x, y2, 'b.', lw=2, label="f(x) = sinc(x)")

    # Add grid, labels, title, and legend
    plt.xlabel('x', fontsize=12)
    plt.ylabel('y(x)', fontsize=12)
    plt.title("Plotting Two Functions Together", fontsize=14)
    plt.legend(loc='best')  # Legend with auto location
    plt.grid(True, which='both', linestyle='--', linewidth=0.5)  # Custom grid style

    # Save the plot to a PDF file
    plt.savefig("two_functions_plot.pdf", format='pdf')

    # Display the plot
    plt.show()


# --- Plotting Subplots ---
def plot_subplots():
    # Define x-range for the plots
    xmin, xmax, Npoints = -5, 5, 500
    dx = (xmax - xmin) / Npoints

    # Create x arrays for different resolutions
    x1 = np.arange(xmin, xmax, dx)
    x2 = np.arange(xmin, xmax, dx / 20)

    # Define functions for y values
    y1 = -np.sin(x1) * np.cos(x1**2)  # Function 1
    y2 = np.exp(-x2 / 4) * np.sin(x2)  # Function 2
    y3 = np.exp(-x1**2 / 4)  # Function 3 (Gaussian)
    y4 = np.sin(x2)  # Function 4 (Sinusoidal)

    # Create a new figure
    plt.figure(figsize=(10, 8))

    # First subplot (top-left)
    plt.subplot(2, 2, 1)
    plt.plot(x1, y1, 'r-', lw=2, label="f(x) = -sin(x) * cos(x^2)")
    plt.title("Function 1: Sin(x)*Cos(x^2)")
    plt.xlabel('x')
    plt.ylabel('y1(x)')
    plt.grid(True)

    # Second subplot (top-right)
    plt.subplot(2, 2, 2)
    plt.plot(x2, y2, 'b-', lw=2, label="f(x) = exp(-x/4) * sin(x)")
    plt.title("Function 2: exp(-x/4) * Sin(x)")
    plt.xlabel('x')
    plt.ylabel('y2(x)')
    plt.grid(True)

    # Third subplot (bottom-left)
    plt.subplot(2, 2, 3)
    plt.plot(x1, y3, 'k--', lw=2, label="f(x) = exp(-x^2/4)")
    plt.title("Function 3: Gaussian")
    plt.xlabel('x')
    plt.ylabel('y3(x)')
    plt.grid(True)

    # Fourth subplot (bottom-right)
    plt.subplot(2, 2, 4)
    plt.plot(x2, y4, 'g+-', lw=2, label="f(x) = sin(x)")
    plt.title("Function 4: Sin(x)")
    plt.xlabel('x')
    plt.ylabel('y4(x)')
    plt.grid(True)

    # Adjust layout to avoid overlap and display the plot
    plt.tight_layout()
    plt.show()

    # Save the subplots to a PDF file
    plt.savefig("subplots_example.pdf", format='pdf')


# --- Main Function ---
if __name__ == "__main__":
    # Plot two functions together
    plot_two_functions()

    # Plot subplots
    plot_subplots()

import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D

# --- 1. Contour Plot ---
def contour_plot():
    # Create a meshgrid for x and y values
    x = np.linspace(-5, 5, 100)
    y = np.linspace(-5, 5, 100)
    X, Y = np.meshgrid(x, y)

    # Define a function for Z values (e.g., f(x, y) = sin(x) * cos(y))
    Z = np.sin(X) * np.cos(Y)

    # Create contour plot
    plt.figure(figsize=(8, 6))
    contour = plt.contour(X, Y, Z, 20, cmap='viridis')  # 20 levels, 'viridis' colormap
    plt.colorbar(contour)  # Add a color bar to the plot
    plt.title('Contour Plot: f(x, y) = sin(x) * cos(y)', fontsize=14)
    plt.xlabel('x')
    plt.ylabel('y')
    plt.grid(True)
    plt.savefig("contour_plot.pdf", format='pdf')
    plt.show()

# --- 2. 3D Surface Plot ---
def surface_plot():
    # Create a meshgrid for x, y values
    x = np.linspace(-5, 5, 100)
    y = np.linspace(-5, 5, 100)
    X, Y = np.meshgrid(x, y)

    # Define a function for Z values (e.g., f(x, y) = x^2 - y^2)
    Z = X**2 - Y**2

    # Create a figure for the 3D plot
    fig = plt.figure(figsize=(10, 7))
    ax = fig.add_subplot(111, projection='3d')

    # Plot a surface with colormap and wireframe
    surface = ax.plot_surface(X, Y, Z, cmap='plasma', edgecolor='k', linewidth=0.5)
    fig.colorbar(surface)  # Add color bar to the surface plot
    ax.set_title("3D Surface Plot: f(x, y) = x^2 - y^2", fontsize=14)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    plt.savefig("surface_plot.pdf", format='pdf')
    plt.show()

# --- 3. Heatmap ---
def heatmap_plot():
    # Create random data for heatmap
    data = np.random.rand(10, 10)

    # Create heatmap
    plt.figure(figsize=(8, 6))
    heatmap = plt.imshow(data, cmap='coolwarm', interpolation='nearest')
    plt.colorbar(heatmap)  # Add a color bar to the heatmap
    plt.title('Heatmap of Random Data', fontsize=14)
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.grid(False)
    plt.savefig("heatmap_plot.pdf", format='pdf')
    plt.show()

# --- 4. Polar Plot ---
def polar_plot():
    # Generate data for polar plot (radius and angle)
    theta = np.linspace(0, 2*np.pi, 100)
    r = np.sin(2*theta) * np.cos(2*theta)

    # Create polar plot
    plt.figure(figsize=(8, 6))
    plt.subplot(111, projection='polar')
    plt.plot(theta, r, label='r = sin(2θ) * cos(2θ)', color='orange')
    plt.title('Polar Plot: r = sin(2θ) * cos(2θ)', fontsize=14)
    plt.legend(loc='upper right')
    plt.grid(True)
    plt.savefig("polar_plot.pdf", format='pdf')
    plt.show()

# --- Main Function ---
if __name__ == "__main__":
    # Call the individual plotting functions
    contour_plot()
    surface_plot()
    heatmap_plot()
    polar_plot()

import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

# --- 1. Stacked Bar Plot ---
def stacked_bar_plot():
    # Data for the stacked bar plot
    categories = ['Category 1', 'Category 2', 'Category 3', 'Category 4']
    group1 = np.array([5, 10, 15, 20])
    group2 = np.array([10, 15, 5, 25])
    group3 = np.array([20, 5, 10, 5])

    # Create a figure and axis for the stacked bar plot
    plt.figure(figsize=(8, 6))

    # Stack the bars
    plt.bar(categories, group1, label='Group 1', color='b')
    plt.bar(categories, group2, bottom=group1, label='Group 2', color='g')
    plt.bar(categories, group3, bottom=group1+group2, label='Group 3', color='r')

    # Add labels, title, and legend
    plt.xlabel('Categories')
    plt.ylabel('Values')
    plt.title('Stacked Bar Plot')
    plt.legend()

    # Save the plot to a PDF file
    plt.savefig("stacked_bar_plot.pdf", format='pdf')
    plt.show()

# --- 2. Violin Plot ---
def violin_plot():
    # Generate random data for the violin plot
    data = np.random.rand(10, 5)

    # Create a figure and axis for the violin plot
    plt.figure(figsize=(8, 6))

    # Create the violin plot using Seaborn for advanced styling
    sns.violinplot(data=data, inner='quart', palette='Set2')

    # Add labels and title
    plt.title('Violin Plot')
    plt.xlabel('Group')
    plt.ylabel('Values')

    # Save the plot to a PDF file
    plt.savefig("violin_plot.pdf", format='pdf')
    plt.show()

# --- 3. Box Plot ---
def box_plot():
    # Generate random data for the box plot
    data = np.random.normal(0, 1, (100, 4))

    # Create a figure and axis for the box plot
    plt.figure(figsize=(8, 6))

    # Create the box plot using Seaborn for enhanced aesthetics
    sns.boxplot(data=data, palette='coolwarm')

    # Add labels and title
    plt.title('Box Plot')
    plt.xlabel('Groups')
    plt.ylabel('Values')

    # Save the plot to a PDF file
    plt.savefig("box_plot.pdf", format='pdf')
    plt.show()

# --- 4. Multiple Y-Axes Plot ---
def multiple_y_axes_plot():
    # Generate random data for two different y-axes
    x = np.linspace(0, 10, 100)
    y1 = np.sin(x)
    y2 = np.cos(x)

    # Create a figure and axis for the multiple Y-axes plot
    fig, ax1 = plt.subplots(figsize=(10, 6))

    # Plot the first y-axis
    ax1.plot(x, y1, 'r-', label='sin(x)', lw=2)
    ax1.set_xlabel('X-axis')
    ax1.set_ylabel('sin(x)', color='r')
    ax1.tick_params(axis='y', labelcolor='r')

    # Create a second y-axis
    ax2 = ax1.twinx()
    ax2.plot(x, y2, 'b-', label='cos(x)', lw=2)
    ax2.set_ylabel('cos(x)', color='b')
    ax2.tick_params(axis='y', labelcolor='b')

    # Add a title
    plt.title('Multiple Y-Axes Plot: sin(x) and cos(x)')

    # Save the plot to a PDF file
    plt.savefig("multiple_y_axes_plot.pdf", format='pdf')
    plt.show()

# --- 5. Annotated Plot ---
def annotated_plot():
    # Generate data for the plot
    x = np.linspace(0, 10, 100)
    y = np.sin(x)

    # Create a figure and axis for the plot
    plt.figure(figsize=(8, 6))

    # Plot the sine wave
    plt.plot(x, y, label='sin(x)', color='m', lw=2)

    # Annotate specific points
    plt.annotate('Maximum', xy=(np.pi / 2, 1), xytext=(np.pi / 2 + 1, 1.2),
                 arrowprops=dict(facecolor='black', arrowstyle='->'),
                 fontsize=12, color='black')
    plt.annotate('Minimum', xy=(3 * np.pi / 2, -1), xytext=(3 * np.pi / 2 + 1, -1.3),
                 arrowprops=dict(facecolor='black', arrowstyle='->'),
                 fontsize=12, color='black')

    # Add labels and title
    plt.xlabel('X')
    plt.ylabel('sin(x)')
    plt.title('Annotated Plot of sin(x)')

    # Show the legend
    plt.legend()

    # Save the plot to a PDF file
    plt.savefig("annotated_plot.pdf", format='pdf')
    plt.show()

# --- Main Function ---
if __name__ == "__main__":
    # Call the individual plotting functions
    stacked_bar_plot()
    violin_plot()
    box_plot()
    multiple_y_axes_plot()
    annotated_plot()

import matplotlib.pyplot as plt
import numpy as np

# --- 1. Streamline Plot ---
def streamline_plot():
    # Create a meshgrid for X and Y values
    Y, X = np.mgrid[-3:3:100j, -3:3:100j]

    # Define the vector field for streamlines
    U = -1 - X**2 + Y
    V = 1 + X - Y**2

    # Create a figure for the streamline plot
    plt.figure(figsize=(8, 6))

    # Plot the streamlines
    plt.streamplot(X, Y, U, V, color='blue', linewidth=1)

    # Add labels and title
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.title('Streamline Plot')

    # Save and show the plot
    plt.savefig("streamline_plot.pdf", format='pdf')
    plt.show()

# --- 2. Error Bar Plot ---
def error_bar_plot():
    # Generate some data with random noise
    x = np.linspace(0, 10, 10)
    y = np.sin(x) + np.random.normal(0, 0.2, 10)
    yerr = np.random.normal(0.1, 0.02, 10)  # Error bars

    # Create a figure for the error bar plot
    plt.figure(figsize=(8, 6))

    # Plot with error bars
    plt.errorbar(x, y, yerr=yerr, fmt='o', color='red', ecolor='blue', elinewidth=2, capsize=5)

    # Add labels and title
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.title('Error Bar Plot')

    # Save and show the plot
    plt.savefig("error_bar_plot.pdf", format='pdf')
    plt.show()

# --- 3. Hexbin Plot ---
def hexbin_plot():
    # Create random data for hexbin plot
    x = np.random.randn(10000)
    y = np.random.randn(10000)

    # Create a figure for the hexbin plot
    plt.figure(figsize=(8, 6))

    # Plot hexbin with a color map
    plt.hexbin(x, y, gridsize=50, cmap='YlGnBu')
    plt.colorbar()  # Show the color bar

    # Add labels and title
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.title('Hexbin Plot')

    # Save and show the plot
    plt.savefig("hexbin_plot.pdf", format='pdf')
    plt.show()

# --- 4. Polar Bar Plot ---
def polar_bar_plot():
    # Generate data for the polar bar plot
    theta = np.linspace(0, 2*np.pi, 12)
    r = np.abs(np.sin(theta) * 10)

    # Create a figure for the polar bar plot
    plt.figure(figsize=(8, 6))

    # Create a polar subplot
    ax = plt.subplot(111, projection='polar')

    # Plot the data as a bar plot
    bars = ax.bar(theta, r, width=0.3, bottom=0.0, color='orange', alpha=0.7)

    # Add labels and title
    ax.set_title('Polar Bar Plot')

    # Save and show the plot
    plt.savefig("polar_bar_plot.pdf", format='pdf')
    plt.show()

# --- 5. 3D Contour Plot ---
def contour3d_plot():
    # Create a grid of x, y values
    x = np.linspace(-5, 5, 100)
    y = np.linspace(-5, 5, 100)
    X, Y = np.meshgrid(x, y)

    # Define the function for Z values
    Z = np.sin(np.sqrt(X**2 + Y**2))

    # Create a figure for the 3D contour plot
    fig = plt.figure(figsize=(10, 7))
    ax = fig.add_subplot(111, projection='3d')

    # Plot the 3D contour plot
    ax.contour3D(X, Y, Z, 50, cmap='viridis')

    # Add labels and title
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title('3D Contour Plot')

    # Save and show the plot
    plt.savefig("contour3d_plot.pdf", format='pdf')
    plt.show()

# --- Main Function ---
if __name__ == "__main__":
    # Call the individual plotting functions
    streamline_plot()
    error_bar_plot()
    hexbin_plot()
    polar_bar_plot()
    contour3d_plot()

import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns


# --- Stacked Area Plot ---
def stacked_area_plot():
    # Generate random data for the stacked area plot
    x = np.arange(0, 10, 0.1)
    y1 = np.sin(x)
    y2 = np.cos(x)
    y3 = np.sin(x) * np.cos(x)

    # Create a figure for the stacked area plot
    plt.figure(figsize=(10, 6))

    # Plot the stacked area plot
    plt.stackplot(x, y1, y2, y3, labels=['sin(x)', 'cos(x)', 'sin(x)*cos(x)'], alpha=0.6)

    # Add labels, title, and legend
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.title('Stacked Area Plot')
    plt.legend(loc='upper left')

    # Save and show the plot
    plt.savefig("stacked_area_plot.pdf", format='pdf')
    plt.show()


# ---Polar Scatter Plot ---
def polar_scatter_plot():
    # Generate data for the polar scatter plot
    theta = np.linspace(0, 2*np.pi, 100)
    r = np.abs(np.sin(theta) * np.cos(theta))
    colors = np.random.rand(100)  # Random color values for the points
    sizes = 50 * np.abs(np.cos(theta))  # Size of the points

    # Create a figure for the polar scatter plot
    plt.figure(figsize=(8, 6))

    # Create the polar scatter plot
    ax = plt.subplot(111, projection='polar')
    scatter = ax.scatter(theta, r, c=colors, s=sizes, cmap='plasma', alpha=0.75)

    # Add color bar and title
    plt.colorbar(scatter, label='Color intensity')
    ax.set_title('Polar Scatter Plot')

    # Save and show the plot
    plt.savefig("polar_scatter_plot.pdf", format='pdf')
    plt.show()

# --- Main Function ---
if __name__ == "__main__":
    # Call the individual plotting functions

    stacked_area_plot()
    polar_scatter_plot()

import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns



# --- 2. Orbital Trajectory Plot ---
def orbital_trajectory():
    # Define parameters for an elliptical orbit (Kepler's law)
    semi_major_axis = 10  # AU
    eccentricity = 0.5
    t = np.linspace(0, 2 * np.pi, 1000)  # Time for one complete orbit

    # Calculate the radius for each time step (ellipse equation)
    r = semi_major_axis * (1 - eccentricity ** 2) / (1 + eccentricity * np.cos(t))

    # Define the position in polar coordinates
    x = r * np.cos(t)
    y = r * np.sin(t)

    # Create a figure for the orbital plot
    plt.figure(figsize=(8, 8))
    plt.plot(x, y, label="Orbital trajectory", color='orange')

    # Add labels and title
    plt.xlabel('X (AU)')
    plt.ylabel('Y (AU)')
    plt.title('Orbital Trajectory of a Planet')
    plt.axhline(0, color='black',linewidth=0.5)
    plt.axvline(0, color='black',linewidth=0.5)
    plt.grid(True)
    plt.gca().set_aspect('equal', adjustable='box')

    # Save and show the plot
    plt.savefig("orbital_trajectory.pdf", format='pdf')
    plt.show()

# --- 3. Phase Plot of a Binary Star System ---
def phase_plot():
    # Generate time and phase data for a binary star system
    time = np.linspace(0, 10, 1000)  # Time in years
    orbital_period = 3  # Period in years
    phase = np.sin(2 * np.pi * time / orbital_period)

    # Create a figure for the phase plot
    plt.figure(figsize=(8, 6))
    plt.plot(time, phase, color='purple', label='Binary star system phase')

    # Add labels and title
    plt.xlabel('Time (years)')
    plt.ylabel('Phase')
    plt.title('Phase Plot of a Binary Star System')
    plt.legend()

    # Save and show the plot
    plt.savefig("phase_plot.pdf", format='pdf')
    plt.show()

# --- 4. Spectral Line Plot ---
def spectral_line_plot():
    # Generate a Gaussian line profile for a spectral line
    wavelength = np.linspace(5000, 5100, 1000)  # Wavelength in Angstroms
    central_wavelength = 5050  # Central wavelength of the spectral line
    sigma = 2  # Standard deviation (linewidth)
    intensity = np.exp(-0.5 * ((wavelength - central_wavelength) / sigma) ** 2)  # Gaussian profile

    # Create a figure for the spectral line plot
    plt.figure(figsize=(8, 6))
    plt.plot(wavelength, intensity, color='blue')

    # Add labels and title
    plt.xlabel('Wavelength (Å)')
    plt.ylabel('Intensity')
    plt.title('Spectral Line Profile')

    # Save and show the plot
    plt.savefig("spectral_line_plot.pdf", format='pdf')
    plt.show()

# --- 5. Star Distribution Map (Galaxy) ---
def star_distribution_map():
    # Generate random positions for stars in a galaxy
    num_stars = 1000
    x = np.random.uniform(-1, 1, num_stars) * 10  # X-coordinate (parsecs)
    y = np.random.uniform(-1, 1, num_stars) * 10  # Y-coordinate (parsecs)

    # Create a scatter plot to represent the distribution of stars
    plt.figure(figsize=(8, 8))
    plt.scatter(x, y, s=1, color='white', alpha=0.5)

    # Add labels and title
    plt.xlabel('X (Parsecs)')
    plt.ylabel('Y (Parsecs)')
    plt.title('Star Distribution in a Galaxy')
    plt.gca().set_facecolor('black')
    plt.grid(True)

    # Save and show the plot
    plt.savefig("star_distribution_map.pdf", format='pdf')
    plt.show()

# --- Main Function ---
if __name__ == "__main__":
    # Call the individual plotting functions

    orbital_trajectory()
    phase_plot()
    spectral_line_plot()
    star_distribution_map()